/*
Navicat MySQL Data Transfer

Source Server         : 192.168.1.99
Source Server Version : 50639
Source Host           : 192.168.1.99:3306
Source Database       : so

Target Server Type    : MYSQL
Target Server Version : 50639
File Encoding         : 65001

Date: 2019-08-23 17:47:22
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `so_article`
-- ----------------------------
DROP TABLE IF EXISTS `so_article`;
CREATE TABLE `so_article` (
  `sid` bigint(20) NOT NULL AUTO_INCREMENT,
  `uid` varchar(40) NOT NULL,
  `title` varchar(60) NOT NULL,
  `desc` varchar(300) DEFAULT NULL,
  `category` tinyint(1) NOT NULL,
  `type` tinyint(1) NOT NULL,
  `tag` varchar(255) DEFAULT NULL,
  `back` varchar(255) DEFAULT NULL,
  `file` varchar(600) DEFAULT NULL,
  `editor` tinyint(1) NOT NULL DEFAULT '1' COMMENT '富文本编辑器内容',
  `content` text NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '0',
  `create_time` datetime NOT NULL,
  `update_time` datetime NOT NULL,
  PRIMARY KEY (`sid`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of so_article
-- ----------------------------
INSERT INTO `so_article` VALUES ('4', '8AC4E8DG918B1', 'Git快速查询手册', 'Git快速查询手册', '1', '2', '[版本控制],[Git]', '', null, '2', '# Git学习笔记\n****\n#### 目录\n[Git简介](#git简介)  \n\n[安装Git](#安装git)  \n\n[创建版本库](#创建版本库)||[使用vi编辑器](#使用vi编辑器)||[把文件添加到版本库](#把文件添加到版本库)||[查看工作区当前状态](#查看工作区当前状态)  \n\n[时光穿梭-版本回退与重返未来](#时光穿梭)  \n\n[工作区与暂存区-管理修改比较不同](#工作区与暂存区)  \n\n[撤销修改](#撤销修改)||[删除文件](#删除文件)  \n\n[远程仓库](#远程仓库)  \n\n[分支管理](#分支管理)||[Bug分支](#bug分支)||[Feature分支](#feature分支)  \n\n[多人协作](#多人协作)\n\n[标签管理](#标签管理)||[操作标签](#操作标签)  \n\n[使用GitHub和码云](#使用github)\n\n[自定义Git](#自定义git)  \n****\n## Git简介\n* Git是分布式版本控制系统\n* 集中式VS分布式：  \n1. 集中式版本控制系统，版本库集中存放在中央服务器，必须要联网才能工作,没有历史版本库。   \n2. 分布式版本控制系统，没有“中央服务器”，每个开发人员电脑上都有一个完整的版本库。  \n3. 分布式优势：安全性更高，无需联网，若“中央服务器”故障，任何一个其他开发者本地都有最新的带历史记录的版本库。  \n4. 主要区别在于历史版本库的存放，集中式历史版本只存在于中央服务器，而分布式中每个本地库都有历史记录存放。\n## 安装Git\n* Linux系统  \n\nDebian或Ubuntu Linux\n```\nsudo apt-get install git\n```\n老版本Debian或Ubuntu Linux\n```\nsudo apt-get install git-core\n```\n其他版本Linux，官网下载源码解压，然后依次输入\n```\n./config ——> make ——> sudo make install\n```\n* Windows系统  \n\n[官网下载](https://git-scm.com/downloads)，安装完成后，“Git”->“Git Bash”即可打开\n\n#### Git配置\n``` \n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n**注意**  `--global`参数表示你这台机器上所有的Git仓库都会使用这个配置。\n# Git命令\n****\n## 创建版本库\n#### 选择一个合适目录  \nWindows系统请确保目录名（包括父目录）不包含中文\n1. 如`$ cd d:`\n2. `$ mkdir <repository-name>`，创建库名\n3. `$ cd <repository-name>`，进入库内  \n\n**补充**  `pwd`显示路径，`ls`显示当前目录，`ls -ah`显示隐藏目录\n#### 在当前目录初始化库\n```\n$ git init\n```\n## 使用vi编辑器\n1. `$ vi <file-name>`，新建或修改文件\n2. 按`i`进入编辑\n3. 编辑完成后按`ESC`，然后选择以下某个命令输入\n\n|命令|效果|\n|--|--|\n|`:w`|保存文件，不退出vi|\n|`:w <file-name>`|另存为file,不退出|\n|`:w!`|强制保存，不退出|\n|`:wq`|保存文件，退出|\n|`:wq!`|强制保存，退出|\n|`:q`|不保存，退出|\n|`:q!`|不保存，强制退出|\n|`:e!`|放弃所有修改，回到上次保存文件开始编辑|  \n\n查看文件内容\n```\ncat <file-name>\n```\n## 把文件添加到版本库\n```\n$ git add <file-name>\n$ git commit -m \"description\"\n```\n**注意**  可以多次`git add `，最后一次`git commit`\n## 查看工作区当前状态\n```\n$ git status\n```\n## 时光穿梭\n```\n$ git reset --hard commit-id\n``` \n### 确定版本回退commit-id\n#### 通过查看提交历史\n```\n$ git log\n```\n按`q`退出查看 \n#### 简化显示提交历史\n```\n$ git log --pretty=oneline\n````\n`HEAD`，当前版本  \n\n`HEAD^`，上个版本  \n\n`HEAD^^`，上上个版本  \n\n`HEAD~100`，往上100个版本\n\n### 确定重返未来commit-id\n#### 通过查看命令历史\n```\n$ git reflog\n```\n## 工作区与暂存区\n![](https://camo.githubusercontent.com/14659c736537a60e9cf0076be119e14ef3cb089a/68747470733a2f2f63646e2e6c69616f78756566656e672e636f6d2f63646e2f66696c65732f6174746163686d656e74732f30303133383439303737303239313733343637323965396166626634313237623664666261653932303761663031363030302f30)  \n\n工作区就是电脑中能看到的目录，工作区有一个隐藏目录`.git`，这是Git的版本库 \n### 管理修改\n#### 修改但未add\n* 比较工作区与暂存区（即上次git add的内容）的不同  \n\n比较所有修改文件的不同\n```\n$ git diff\n```\n比较指定修改文件的不同\n```\n$ git diff <file-name>\n```\n#### 修改已add但未commit\n* 比较暂存区与仓库分支（上次git commit）的不同\n```\n$ git diff --staged\n```\n或\n```\n$ git diff --cached\n```\n## 撤销修改\n* 场景1——工作区已修改但未add到暂存区  \n```\n$ git checkout -- <file-name>\n```\n其实就是用版本库里的版本替换工作区的版本\n* 场景2——工作区修改且已经git add到暂存区，分两步 \n```\n$ git reset HEAD <file-name>\n```\n回到场景1，再按场景1操作\n* 场景3：已经commit但没有推送到远程库——**版本回退**\n## 删除文件\n假设文件原已commit，目前情况是——已经在目录下手动或`$ rm <file-name>`删除文件\n* 选择一：确实要从版本库中删除该文件，分两步  \n\n第一步\n```\n$ git rm <file-name>\n```\n或\n```\ngit add <file-name>\n```  \n第二步\n```\n$ git commit -m \"description\"\n```  \n* 选择二：删错了，要恢复  \n```\n$ git checkout -- <file-name>\n```\n其实就是用版本库里的版本替换工作区的版本\n## 远程仓库\n#### 创建SSH Key\n```\n$ ssh-keygen -t rsa -C \"youremail@example.com\"\n```  \n\n**补充**  在用户主目录下(`cd`)  \n\n`$ ls -ah`可见`.ssh`目录  \n\n`$ cd .ssh`可见`id_rsa`(私钥不能泄露)和`id_rsa.pub`(公钥可公开)\n#### 关联远程仓库\n```\n$ git remote add origin git@github.com:username/repositoryname.git\n```\n或\n```\n$ git remote add origin https://github.com/username/repositoryname.git\n```  \n远程库默认名字为`origin`\n#### 删除已经关联的远程库\n```\ngit remote rm remote-name\n```\n若远程库默认名字为`origin`，则\n```\ngit remote rm origin\n```\n#### 推送到远程仓库\n* 第一次推送到GitHub  \n```\n$ git push -u origin master\n```\n推送master分支\n* 后续推送\n```\n$ git push origin master\n```\n不再使用参数`-u`\n#### 从远程库克隆\n```\n$ git clone git@github.com:username/repositoryname.git\n```  \n或  \n```\n$ git clone https://github.com/username/repositoryname.git\n```\n## 分支管理\n#### 查看分支\n```\n$ git branch\n```\n#### 创建分支\n```\n$ git branch <branch-name>\n```\n#### 切换分支\n```\n$ git checkout <branch-name>\n```\n#### 创建+切换分支\n```\n$ git checkout -b <branch-name>\n```\n#### 合并某分支到当前分支\n```\n$ git merge <branch-name>\n```\n#### 普通模式合并分支\n```\n$ git merge --no-ff -m \"description\" <branch-name>\n```  \n通常进行分支合并时，如果可以，Git会使用`Fast forward`模式，删除分支后，分支历史信息会丢失  \n\n`--no-ff`表示禁用`Fast forward`模式，能看出曾做过合并\n#### 删除分支\n```\n$ git branch -d <branch-name>\n```\n#### 强行删除分支\n```\n$ git branch -D <branch-name>\n```\n#### 查看分支合并图\n```\n$ git log --graph\n```  \n简洁查看\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n```\n### Bug分支\n假设场景——设A为游戏软件  \n\n1. master 上面发布的是A的1.0版本\n2. dev 上开发的是A的2.0版本\n3. 这时，用户反映 1.0版本存在漏洞，有人利用这个漏洞开外挂\n4. 需要从dev切换到master去填这个漏洞，正常必须先提交dev目前的工作，才能切换\n5. 而dev的工作还未完成，不想提交，所以先把dev的工作stash一下。然后切换到master\n6. 在master建立分支issue101并切换\n7. 在issue101上修复漏洞\n8. 修复后，在master上合并并删除issue101\n9. 切回dev，恢复原本工作，继续工作\n#### 保存工作现场\n```\n$ git stash\n```\n#### 查看保存的工作现场\n```\n$ git stash list\n```\n#### 恢复工作现场\n```\n$ git stash apply\n```\n#### 删除工作现场\n```\n$ git stash drop\n```\n#### 恢复并删除工作现场\n```\ngit stash pop\n```\n### Feature分支\n每添加一个新功能，最好新建一个feature分支，在上面开发完成后，合并，最后，删除该feature分支\n## 多人协作\n#### 多人协作通常的工作模式\n1. 先试图推送自己的修改`git push`\n2. 若推送失败，则远程分支比本地分支更新，`git pull`拉取远程分支试图合并\n3. 若合并有冲突，则解决冲突，并在本地提交(`add` 和 `commit`)\n4. 若没有冲突或解决了冲突，再次推送`git push`\n#### 查看远程库信息\n```\n$ git remote\n```\n详细查看\n```\ngit remote -v\n```\n#### 本地推送分支\n```\n$ git push origin <branch-name>\n```\n#### 在本地创建和远程分支对应的分支\n```\n$ git checkout -b <branch-name> origin/<branch-name>\n```\n#### 建立本地分支和远程分支的关联\n```\n$ git branch --set-upstream <branch-name> origin/<branch-name>\n```  \n或  \n```\n$ git branch --set-upstream-to=origin/<branch-name> <branch-name>\n```\n#### 从远程抓取分支\n```\n$ git pull\n```\n## Rebase“变基”  \n```\n$ git rebase\n```  \n把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。  \n\n只对尚未推送或尚未分享给别人的本地修改执行变基操作清理历史，从不对已推送至别处的提交执行变基操作\n## 标签管理\n发布一个版本时，我们通常先在版本库中打一个标签（`tag`），这样，就唯一确定了打标签时刻的版本  \n\n将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照\n#### 创建标签\n```\n$ git tag <tag-name>\n```\n在最新commit上打一个标签  \n```\n$ git tag <tag-name> commit-id\n```\n在对应的commit_id上打一个新标签\n#### 创建带有说明的标签\n```\n$ git tag -a <tag-name> -m \"description\" commit-id\n```\n`-a`指定标签名，`-m`指定说明文字  \n#### 查看所有标签\n```\n$ git tag\n```  \n#### 查看对应标签的信息\n```\n$ git show <tag-name>\n```\n**注意**标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。\n### 操作标签\n#### 推送某个标签到远程\n```\n$ git push origin <tag-name>\n```\n#### 一次性推送全部尚未推送的标签到远程\n```\ngit push origin --tags\n```\n#### 删除一个本地标签\n```\n$ git tag -d <tag-name>\n```\n#### 删除一个远程标签\n先从本地删除  \n```\n$ git tag -d <tag-name>\n```\n再从远程删除\n```\n$ git push origin :refs/tags/<tag-name>\n```\n## 使用GitHub\n如何参与一个开源项目  \n\n`Fork`任意开源库 ——> 从自己的账户下`clone` ——> 修复bug或者新增一个功能 ——> 若希望官方库接受你的修改，可以在GitHub上发起一个`pull request`\n## 本地库既关联GitHub，又关联码云\n如原来已经关联了默认名`origin`的GitHub  \n1. 先删除已关联的名为`origin`的远程库：\n```\n$ git remote rm origin\n```\n2. 然后，先关联GitHub的远程库：\n```\n$ git remote add github git@github.com:username/repositoryname.git\n```\n注意，远程库的名称叫`github`，不叫`origin`了  \n\n3. 接着，再关联码云的远程库：\n```\n$ git remote add gitee git@gitee.com:username/repositoryname.git\n```\n同样注意，远程库的名称叫`gitee`，不叫`origin`了  \n\n**注意**  多个关联后以上所以命令含的`origin`都换成相应的`github`或`gitee`  \n\n如果要推送到GitHub，使用命令：\n```\n$ git push github master\n```\n如果要推送到码云，使用命令：\n```\n$ git push gitee master\n```\n## 自定义Git\n#### 显示颜色\n让Git显示颜色，会让命令输出看起来更醒目：  \n```\n$ git config --global color.ui true\n```\n#### 忽略特殊文件\n[见廖老师教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000)\n#### 配置别名\n如\n* 用`git st`就表示`git status`\n```\n$ git config --global alias.st status\n```\n* 配置一个`git last`，让其显示最后一次提交信息：\n```\n$ git config --global alias.last \'log -1\'\n```\n* 甚至还有人丧心病狂地把lg配置成了：\n```\n$ git config --global alias.lg \"log --color --graph --pretty=format:\'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset\' --abbrev-commit\"\n```\n试试`git lg`的效果，很炫酷\n#### 配置文件\n* 配置Git的时候，加上`--global`是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用  \n* 查看用户的配置信息：\n```\n$ git config --global --list\n```\n要查看当前仓库的，把`global`改成`local`就好\n* 配置文件放哪了？每个仓库的Git配置文件都放在`.git/config`文件中：`$ cat .gitconfig`\n* 别名就在`alias`后面，要删除别名，直接把对应的行删掉即可\n#### 搭建Git服务器\nGitHub就是一个免费托管开源代码的远程仓库  \n\n但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用  \n\n[搭建见廖老师教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000)\n', '1', '2019-08-12 16:57:20', '2019-08-14 14:24:09');
INSERT INTO `so_article` VALUES ('13', '8AC4E8DG918B1', 'nvm的下载和安装使用', 'nvm是一个nodejs的版本控制,它可以有效的切换nodejs和npm的版本,方便项目的开发.', '7', '1', '[前端],[nvm],[nvm-windows],[nodejs],[npm]', '', '{}', '2', '### 1. nvm的作用\n进行nodejs的版本控制.\n### 2. nvm的下载地址\nhttps://github.com/coreybutler/nvm-windows/releases\n(网速可能会影响下载)\n链接：https://pan.baidu.com/s/1DEk3-VJghC5Aze-ksxibsw提取码：8xtw(外部使用)\n### 3. nvm的安装\n1. nvm-noinstall.zip： 这个是绿色免安装版本，但是使用之前需要配置\n2. nvm-setup.zip：这是一个安装包，下载之后点击安装，无需配置就可以使用，方便。(推荐使用该版本)\n3. Source code(zip)：zip压缩的源码\n4. Sourc code(tar.gz)：tar.gz的源码，一般用于Linux系统\n安装步骤属于傻瓜式操作，一直next就行了，在此不做截图演示\n\n### 4. 配置路径和下载源\n在nvm安装路径下setting.txt文件中配置如下信息：\n设置nodejs路径(相当于setting.txt中的path:)：\nnvm node_mirror https://npm.taobao.org/mirrors/node/\nnvm npm_mirror https://npm.taobao.org/mirrors/npm/\n\n```\nroot: D:\\nvm  nvm的安装路径\npath: D:\\nodejs	nodejs的安装路径\nnode_mirror:https://npm.taobao.org/mirrors/node/ 下载源\nnpm_mirror:https://npm.taobao.org/mirrors/npm/ 下载源\n```\n\n### 5. 测试nvm\n在电脑命令行输入nvm出现\n```\nRunning Version 1.1.6\nUsage:\n....\n```\n等数据信息标识成功.\n\n### 6. 常用命令\n|命令|说明|\n|:--|:--:|\n|nvm list|查看已经安装的版本|\n|nvm list installed|查看已经安装的版本|\n|nvm list available|查看网络可以安装的版本|\n|nvm arch|查看当前系统的位数和当前nodejs的位数|\n|nvm arch [32\\|64]|显示node是运行在32位还是64位模式。指定32或64来覆盖默认体系结构。|\n|nvm install \\<version\\> [arch]|该可以是node.js版本或最新稳定版本latest。（可选[arch]）指定安装32位或64位版本（默认为系统arch）。设置[arch]为all以安装32和64位版本。在命令后面添加–insecure，可以绕过远端下载服务器的SSL验证。|\n|nvm on|打开nodejs版本控制|\n|nvm off|关闭nodejs版本控制|\n|nvm proxy [url]|查看和设置代理|\n|nvm node_mirror [url]	|设置或者查看setting.txt中的node_mirror，如果不设置的默认是 https://nodejs.org/dist/|\n|nvm npm_mirror [url]|设置或者查看setting.txt中的npm_mirror,如果不设置的话默认的是：https://github.com/npm/npm/archive/.|\n|nvm uninstall|卸载制定的版本|\n|nvm use [version] [arch]|切换制定的node版本和位数-nvm use \\<arch\\>：将继续使用所选版本，但根据提供的值切换到32/64位模式|\n|nvm root [path]|设置 nvm 存储node.js不同版本的目录 ,如果未设置，将使用当前目录。 |\n|nvm version|查看当前的版本|', '1', '2019-08-15 11:21:53', '2019-08-19 14:39:11');
INSERT INTO `so_article` VALUES ('14', '8AC4E8DG918B1', 'nrm NPM源管理工具以及cnpm讲解', 'nrm为npm的源管理工具,他将有效的提交下载速度.', '7', '1', '[nrm],[npm],[前端],[cnpm]', '', null, '2', '### nrm NPM源管理工具\nnrm 是一个可以快速切换NPM源的node插件。由于国内网络的问题，访问npm经常会很慢，所以大家经常会用一些替代方案，如：淘宝的cnpm\n\n目前他已经有6种不同的NPM源（如大家常用的cnpm）\n下面说下nrm的一些用法\n\n### 1. 安装\n```\nnpm install -g nrm\n```\n### 2. 用法\n查看所有的源\n```\nnrm ls\n* npm -----  https://registry.npmjs.org/\n  cnpm ----  http://r.cnpmjs.org/\n  taobao --  https://registry.npm.taobao.org/\n  nj ------  https://registry.nodejitsu.com/\n  rednpm -- http://registry.mirror.cqupt.edu.cn\n  skimdb -- https://skimdb.npmjs.com/registry	\n```\n切换npm源：\n如：切换到cnpm\n```\nnrm use cnpm\n```\n已经就是用法，装了这个插件以后，我们就不用再使用cnpm install xxx这样的命令了。\n\n可以直接使用npm install xxx这样的命令，还是蛮方便的。\n\n### cnpm为淘宝的一个镜像\n网址:http://npm.taobao.org/\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n运行完成以后,就可以采用\ncnpm install....命令了.', '1', '2019-08-15 12:56:14', '2019-08-15 12:56:45');
INSERT INTO `so_article` VALUES ('15', '8AC4E8DG918B1', 'Vue2全家桶之一：vue-cli（vue脚手架）', 'vue-cli这个构建工具大大降低了webpack的使用难度，支持热更新，有webpack-dev-server的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK。', '4', '1', '[前端],[vue.js]', '', '{}', '2', '### 1. 安装vue-cli\n① 使用npm（需要安装node环境）全局安装webpack，打开命令行工具输入：\n```\nnpm install webpack -g或者（npm install -g webpack）\n```\n安装完成之后输入:\n```\nwebpack -v\n```\n出现相应的版本号，则说明安装成功。\n\n② 全局安装vue-cli，在cmd中输入命令:\n```\nnpm install --global vue-cli\n```\n安装成功,如图所示\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a454349054.PNG)\n\n安装完成之后输入 vue -V（注意这里是大写的“V”），如果出现相应的版本号，则说明安装成功。\n\n#### 查看npm目录下安装\n打开C:\\Users\\Andminster\\AppData\\Roaming\\npm目录下可以看到：\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a45997fa71.PNG)\n\n打开node_modules\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a45cb8300e.PNG)\n\n### 2. 用vue-cli来构建项目\n① 我首先在D盘新建一个文件夹（dxl_vue）作为项目存放地，然后使用命令行cd进入到项目目录输入：\n```\nvue init webpack baoge\n```\nbaoge是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹。\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a45fa820a2.PNG)\n输入命令后，会跳出几个选项让你回答：\n\n```\nProject name (baoge)：     -----项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。\n\nProject description (A Vue.js project)：  ----项目描述，也可直接点击回车，使用默认名字\n\nAuthor ()：       ----作者，输入作者名称\n\n接下来会让用户选择：\nRuntime + Compiler: recommended for most users    运行加编译，既然已经说了推荐，就选它了\n\nRuntime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere   仅运行时，已经有推荐了就选择第一个了\n\nInstall vue-router? (Y/n)    是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。\n\nUse ESLint to lint your code? (Y/n)      是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。\n\n接下来也是选择题Pick an ESLint preset (Use arrow keys)            选择一个ESLint预设，编写vue项目时的代码风格，直接y回车\n\nSetup unit tests with Karma + Mocha? (Y/n)  是否安装单元测试，我选择安装y回车\n\nSetup e2e tests with Nightwatch(Y/n)?     是否安装e2e测试 ，我选择安装y回车\n\n```\n回答完毕后上图就开始构建项目了。\n\n② 配置完成后，可以看到目录下多出了一个项目文件夹baoge，然后cd进入这个文件夹：\n```\nnpm install\n```\n如果安装速度太慢。可以安装淘宝镜像，打开命令行工具，输入：\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n```\n然后使用cnpm来安装 或者采用nrm换源的方式\n\nnpm install ：安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。而只输入install就会按照项目的根目录下的package.json文件中依赖的模块安装（这个文件里面是不允许有任何注释的），每个使用npm管理的项目都有这个文件，是npm操作的入口文件。因为是初始项目，还没有任何模块，所以我用npm install 安装所有的模块。安装完成后，目录中会多出来一个node_modules文件夹，这里放的就是所有依赖的模块。\n\n然后现在，baoge文件夹里的目录是这样的：\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a46d8060f2.PNG)\n\n解释下每个文件夹代表的意思(仔细看一下这张图）：\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a46f149570.PNG)\n\n### 3. 启动项目\n```\nnpm run dev\n```\n\n如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config里的index.js\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a4624606f2.PNG)\n\n还有，如果本地调试项目时，建议将build 里的assetsPublicPath的路径前缀修改为 \' ./ \'（开始是 \' / \'），因为打包之后，外部引入 js 和 css 文件时，如果路径以 \' / \' 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径。\n我的端口没有被占用，直接成功（服务启动成功后浏览器会默认打开一个“欢迎页面”）：\n\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a464aca6da.PNG)\n\n注意：在进行vue页面调试时，一定要去谷歌商店下载一个vue-tool扩展程序。\n\n### 4. vue-cli的webpack配置分析\n\n- 从package.json可以看到开发和生产环境的入口。\n![捕获.PNG](http://192.168.1.99/so/service/public/upload/media/5d5a46718a617.PNG)\n\n- 可以看到dev中的设置，build/webpack.dev.conf.js，该文件是开发环境中webpack的配置入口。\n- 在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。\n- 还有config/index.js 、build/utils.js  、build/build.js等，具体请看这篇介绍：\nhttps://segmentfault.com/a/1190000008644830\n\n### 打包上线\n注意，自己的项目文件都需要放到 src 文件夹下。\n在项目开发完成之后，可以输入 npm run build 来进行打包工作。\n```\nnpm run build\n```\n另：\n```\n1.npm 开启了npm run dev以后怎么退出或关闭？\nctrl+c\n2.--save-dev\n自动把模块和版本号添加到模块配置文件package.json中的依赖里devdependencies部分\n3. --save-dev 与 --save 的区别\n--save     安装包信息将加入到dependencies（生产阶段的依赖）\n--save-dev 安装包信息将加入到devDependencies（开发阶段的依赖），所以开发阶段一般使用它\n```\n\n打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。\n项目上线时，只需要将 dist 文件夹放到服务器就行了。\n', '1', '2019-08-15 14:08:18', '2019-08-19 14:51:48');
INSERT INTO `so_article` VALUES ('16', '8AC4E8DG918B1', 'vue-cli各配置文件注释详解', 'vue-cli各配置文件注释详解', '4', '2', '[前端],[vue.js]', '', null, '2', '### 1. build.js\n```\n\'use strict\'\n//立即执行\nrequire(\'./check-versions\')()\n\n//process是node中的global全局对象的属性，process是node中的全局变量，env设置环境变量\nprocess.env.NODE_ENV = \'production\'\n// ora是一个命令行转圈圈动画插件，好看用的\nconst ora = require(\'ora\')\n// rimraf插件是用来执行UNIX命令rm和-rf的用来删除文件夹和文件，清空旧的文件\nconst rm = require(\'rimraf\')\n// node.js路径模块 连接路径，例子：path.join(\'/foo\', \'bar\', \'baz/asdf\', \'quux\', \'..\');// 返回: \'/foo/bar/baz/asdf\'\nconst path = require(\'path\')\n//chalk插件，用来在命令行中输入不同颜色的文字\nconst chalk = require(\'chalk\')\n// 引入webpack模块使用内置插件和webpack方法\nconst webpack = require(\'webpack\')\n//commonJs风格，引入文件模块，引入模块分为内置模块与文件模块两种\nconst config = require(\'../config\')\nconst webpackConfig = require(\'./webpack.prod.conf\')\n// 开启转圈圈动画\nconst spinner = ora(\'building for production...\')\nspinner.start()\n// 调用rm方法，第一个参数的结果就是 绝对/工程名/dist/static，表示删除这个路径下面的所有文件\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  // 如果删除的过程中出现错误，就抛出这个错误，同时程序终止\n  if (err) throw err\n  // 没有错误，就执行webpack编译\n  webpack(webpackConfig, (err, stats) => {\n    // 这个回调函数是webpack编译过程中执行\n    spinner.stop()\n    // 如果有错误就抛出错误\n    if (err) throw err\n    // 没有错误就执行下面的代码，process.stdout.write和console.log类似，输出对象\n    //process.stdout用来控制标准输出，也就是在命令行窗口向用户显示内容。它的write方法等同于console.log\n    process.stdout.write(stats.toString({\n      // stats对象中保存着编译过程中的各种消息\n      colors: true, // 增加控制台颜色开关\n      modules: false, // 不增加内置模块信息\n      children: false, // 不增加子级信息 If you are using ts-loader, setting this to true will make TypeScript errors show up during build.\n      chunks: false, // 允许较少的输出\n      chunkModules: false // 不将内置模块的信息加到包信息\n    }) + \'\\n\\n\')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red(\'  Build failed with errors.\\n\'))\n      process.exit(1)\n    }\n    // 以上就是在编译过程中，持续打印消息 \n    // 下面是编译成功的消息\n    console.log(chalk.cyan(\'  Build complete.\\n\'))\n    console.log(chalk.yellow(\n      \'  Tip: built files are meant to be served over an HTTP server.\\n\' +\n      \'  Opening index.html over file:// won\\\'t work.\\n\'\n    ))\n  })\n})\n```\n\n### 2. check-versions.js\n\n```\n\'use strict\'\n// 该文件用于检测node和npm的版本，实现版本依赖\n//chalk 是一个用来在命令行输出不同颜色文字的包，可以使用chalk.yellow(\"想添加颜色的文字....\")\n//来实现改变文字颜色的;\nconst chalk = require(\'chalk\')\n//semver 的是一个语义化版本文件的npm包，其实它就是用来控制版本的;\nconst semver = require(\'semver\')\nconst packageConfig = require(\'../package.json\')\n//一个用来执行unix命令的包\nconst shell = require(\'shelljs\')\n\n//child_process 是Node.js提供了衍生子进程功能的模块，execSync()方法同步执行一个cmd命令，\n//将返回值的调用toString和trim方法\nfunction exec(cmd) {\n  return require(\'child_process\').execSync(cmd).toString().trim()\n}\n\nconst versionRequirements = [\n  {\n    name: \'node\',\n    //semver.clean()方法返回一个标准的版本号，切去掉两边的空格，比如semver.clean(\" =v1.2.3 \")\n    //返回\"1.2.3\",此外semver还有vaild,satisfies,gt,lt等方法，\n    //这里查看https://npm.taobao.org/package/semver可以看到更多关于semver方法的内容\n    currentVersion: semver.clean(process.version), //使用semver格式化版本\n    versionRequirement: packageConfig.engines.node //获取package.json中设置的node版本的范围\n  }\n]\n\n//shell.which方法是去环境变量搜索有没有参数这个命令\nif (shell.which(\'npm\')) {\n  versionRequirements.push({\n    name: \'npm\',\n    //执行\"npm --version\"命令\n    currentVersion: exec(\'npm --version\'), // 自动调用npm --version命令，并且把参数返回给exec函数，从而获取纯净的版本号\n    versionRequirement: packageConfig.engines.npm\n  })\n}\n\nmodule.exports = function () {\n  const warnings = []\n\n  for (let i = 0; i < versionRequirements.length; i++) {\n    const mod = versionRequirements[i]\n\n    // semver.satisfies()进行版本之间的比较\n    if (!semver.satisfies(mod.currentVersion, mod.versionRequirement)) {\n      //上面这个判断就是如果版本号不符合package.json文件中指定的版本范围，就执行下面错误提示的代码\n      warnings.push(mod.name + \': \' +\n        chalk.red(mod.currentVersion) + \' should be \' +\n        chalk.green(mod.versionRequirement)\n      )\n    }\n  }\n\n  if (warnings.length) {\n    console.log(\'\')\n    console.log(chalk.yellow(\'To use this template, you must update following to modules:\'))\n    console.log()\n\n    for (let i = 0; i < warnings.length; i++) {\n      const warning = warnings[i]\n      console.log(\'  \' + warning)\n    }\n\n    console.log()\n    process.exit(1)\n  }\n}\n```\n\n### 3. utils.js\n```\nuse strict\'\n// 引入nodejs路径模块\nconst path = require(\'path\')\n// 引入config目录下的index.js配置文件\nconst config = require(\'../config\')\n// 引入extract-text-webpack-plugin插件，用来将css提取到单独的css文件中\nconst ExtractTextPlugin = require(\'extract-text-webpack-plugin\')\nconst packageConfig = require(\'../package.json\')\n// exports其实就是一个对象，用来导出方法的，最终还是使用module.exports，此处导出assetsPath\nexports.assetsPath = function (_path) {\n  // 如果是生产环境assetsSubDirectory就是\'static\'，否则还是\'static\'，哈哈哈\n  const assetsSubDirectory = process.env.NODE_ENV === \'production\'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n  // path.join和path.posix.join的区别就是，前者返回的是完整的路径，后者返回的是完整路径的相对根路径\n  // 也就是说path.join的路径是C:a/a/b/xiangmu/b，那么path.posix.join就是b\n  return path.posix.join(assetsSubDirectory, _path)\n  // 所以这个方法的作用就是返回一个干净的相对根路径\n}\n// 下面是导出cssLoaders的相关配置\nexports.cssLoaders = function (options) {\n  // options如果不为null或者undefined，0，\"\"等等就原样，否则就是{}。在js里面,||运算符，A||B，A如果为真，直接返回A。如果为假，直接返回B（不会判断B是什么类型）\n  options = options || {}\n\n  const cssLoader = {\n    // cssLoader的基本配置\n    loader: \'css-loader\',\n    options: {\n      // 是否开启cssmap，默认是false\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: \'postcss-loader\',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  // generate loader string to be used with extract text plugin\n  function generateLoaders(loader, loaderOptions) {\n    // 将上面的基础cssLoader配置放在一个数组里面\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n    // 如果该函数传递了单独的loader就加到这个loaders数组里面，这个loader可能是less,sass之类的\n    if (loader) {\n      // 加载对应的loader\n      loaders.push({\n        loader: loader + \'-loader\',\n        // Object.assign是es6的方法，主要用来合并对象的，浅拷贝\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    // Extract CSS when that option is specified\n    // (which is the case during production build)\n    if (options.extract) {\n      // 注意这个extract是自定义的属性，可以定义在options里面，主要作用就是当配置为true就把文件单独提取，false表示不单独提取，这个可以在使用的时候单独配置，瞬间觉得vue作者好牛逼\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: \'vue-style-loader\',\n        publicPath: \'../../\',\n      })\n    } else {\n      return [\'vue-style-loader\'].concat(loaders)\n    }\n    // 上面这段代码就是用来返回最终读取和导入loader，来处理对应类型的文件\n  }\n\n  // https://vue-loader.vuejs.org/en/configurations/extract-css.html\n  return {\n    css: generateLoaders(),　　　　     // css对应 vue-style-loader 和 css-loader\n    postcss: generateLoaders(),　　// postcss对应 vue-style-loader 和 css-loader\n    less: generateLoaders(\'less\'),// less对应 vue-style-loader 和 less-loader\n    sass: generateLoaders(\'sass\', { indentedSyntax: true }),// sass对应 vue-style-loader 和 sass-loader\n    scss: generateLoaders(\'sass\'),  // scss对应 vue-style-loader 和 sass-loader\n    stylus: generateLoaders(\'stylus\'),// stylus对应 vue-style-loader 和 stylus-loader\n    styl: generateLoaders(\'stylus\')  // styl对应 vue-style-loader 和 styl-loader\n  }\n}\n\n// Generate loaders for standalone style files (outside of .vue)\n// 下面这个主要处理import这种方式导入的文件类型的打包，上面的exports.cssLoaders是为这一步服务的\nexports.styleLoaders = function (options) {\n  const output = []\n  // 下面就是生成的各种css文件的loader对象\n  const loaders = exports.cssLoaders(options)\n  // 把每一种文件的laoder都提取出来\n  for (const extension in loaders) {\n    const loader = loaders[extension]\n    output.push({\n      // 把最终的结果都push到output数组中，大事搞定\n      test: new RegExp(\'\\\\.\' + extension + \'$\'),\n      use: loader\n    })\n  }\n\n  return output\n}\n\n//\'node-notifier\'是一个跨平台系统通知的页面，当遇到错误时，它能用系统原生的推送方式给你推送信息\nexports.createNotifierCallback = () => {\n  const notifier = require(\'node-notifier\')\n\n  return (severity, errors) => {\n    if (severity !== \'error\') return\n\n    const error = errors[0]\n    const filename = error.file && error.file.split(\'!\').pop()\n\n    notifier.notify({\n      title: packageConfig.name,\n      message: severity + \': \' + error.name,\n      subtitle: filename || \'\',\n      icon: path.join(__dirname, \'logo.png\')\n    })\n  }\n}\n```\n\n### 4. vue-loader.conf.js\n```\n\'use strict\'\n// vue-loader的配置，用在webpack.base.conf.js中；\nconst utils = require(\'./utils\')\nconst config = require(\'../config\')\n//不同环境为isProduction 赋值: 生产环境为true，开发环境为false\nconst isProduction = process.env.NODE_ENV === \'production\'\n//不同环境为sourceMapEnabled 赋值: 这里都为true\nconst sourceMapEnabled = isProduction\n  ? config.build.productionSourceMap\n  : config.dev.cssSourceMap\n\n//导出vue-loader的配置，这里我们用了utils文件中的cssLoaders()\nmodule.exports = {\n  loaders: utils.cssLoaders({\n    sourceMap: sourceMapEnabled,\n    extract: isProduction\n  }),\n  cssSourceMap: sourceMapEnabled,\n  cacheBusting: config.dev.cacheBusting,\n  //transformToRequire的作用是在模板编译的过程中，编译器可以将某些属性，如src转换为require调用\n  transformToRequire: {\n    video: [\'src\', \'poster\'],\n    source: \'src\',\n    img: \'src\',\n    image: \'xlink:href\'\n  }\n}\n```\n\n### 5. webpack.base.conf.js\n```\n\'use strict\' //js严格模式执行\n// 引入node.js路径模块\nconst path = require(\'path\')\n// 引入utils工具模块，具体查看我的博客关于utils的解释，utils主要用来处理css-loader和vue-style-loader的\nconst utils = require(\'./utils\')\n// 引入config目录下的index.js配置文件，主要用来定义一些开发和生产环境的属性\nconst config = require(\'../config\')\n// vue-loader.conf配置文件是用来解决各种css文件的，定义了诸如css,less,sass之类的和样式有关的loader\nconst vueLoaderConfig = require(\'./vue-loader.conf\')\n// 返回到dir为止的绝对路径\nfunction resolve(dir) {\n  return path.join(__dirname, \'..\', dir)\n}\n\n// const createLintingRule = () => ({\n//   test: /\\.(js|vue)$/,\n//   loader: \'eslint-loader\',\n//   enforce: \'pre\',\n//   include: [resolve(\'src\'), resolve(\'test\')],\n//   options: {\n//     formatter: require(\'eslint-friendly-formatter\'),\n//     emitWarning: !config.dev.showEslintErrorsInOverlay\n//   }\n// })\n\nmodule.exports = {\n  context: path.resolve(__dirname, \'../\'),\n  entry: {\n    // 入口文件是src目录下的\n    app: \'./src/main.js\'\n  },\n  output: {\n    // 路径是config目录下的index.js中的build配置中的assetsRoot，也就是dist目录,\n    path: config.build.assetsRoot,\n    filename: \'[name].js\', //name就是入口文件前面的key值，此处是index和admin 输出文件名称默认使用原名\n    //资源发布路径  // 上线地址，也就是真正的文件引用路径，\n    publicPath: process.env.NODE_ENV === \'production\'\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  resolve: {\n    // resolve是webpack的内置选项，也就是说当使用 import \"jquery\"，该如何去执行这件事 \n    // 情就是resolve配置项要做的，import jQuery from \"./additional/dist/js/jquery\" 这样会很麻烦，可以起个别名简化操作\n    extensions: [\'.js\', \'.vue\', \'.json\'], // 省略扩展名，也就是说.js,.vue,.json文件导入可以省略后缀名，这会覆盖默认的配置，所以要省略扩展名在这里一定要写上\n    alias: {\n      //我的理解是此处指定别名  require(\'vue/dist/vue.esm.js\') 可以简化为require（\'vue$\'）\n      // resolve(\'src\') 其实在这里就是项目根目录中的src目录，使用 import somejs from \"@/some.js\" 就可以导入指定文件，是不是很高大上\n      \'vue$\': \'vue/dist/vue.esm.js\',\n      \'@\': resolve(\'src\'),\n    }\n  },\n  // module用来解析不同的模块\n  module: {\n    rules: [\n      // ...(config.dev.useEslint ? [createLintingRule()] : []),\n      // 对vue文件使用vue-loader，该loader是vue单文件组件的实现核心，专门用来解析.vue文件的\n      {\n        test: /\\.vue$/,\n        loader: \'vue-loader\', // 将vueLoaderConfig当做参数传递给vue-loader,就可以解析文件中的css相关文件\n        options: vueLoaderConfig\n      },\n      // 对js文件使用babel-loader转码,该插件是用来解析es6等代码\n      {\n        test: /\\.js$/,\n        loader: \'babel-loader\', // 指明src和test目录下的js文件要使用该loader\n        include: [resolve(\'src\'), resolve(\'test\'), resolve(\'node_modules/webpack-dev-server/client\')]\n      },\n      // 对图片相关的文件使用 url-loader 插件，这个插件的作用是将一个足够小的文件生成一个64位的DataURL \n      // 可能有些老铁还不知道 DataURL 是啥，当一个图片足够小，为了避免单独请求可以把图片的二进制代码变成64位的 \n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: \'url-loader\',\n        options: {\n          // 限制 10000 个字节以下转base64，以上不转\n          limit: 10000,\n          name: utils.assetsPath(\'img/[name].[hash:7].[ext]\')\n        }\n      },\n      //音频 视频类文件\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: \'url-loader\',\n        options: {\n          limit: 10000,\n          //超过10000字节的图片，就按照制定规则设置生成的图片名称，可以看到用了7位hash码来标记，.ext文件是一种索引式文件系统\n          name: utils.assetsPath(\'media/[name].[hash:7].[ext]\')\n        }\n      },\n      // 字体文件处理，和上面一样\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: \'url-loader\',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath(\'fonts/[name].[hash:7].[ext]\')\n        }\n      }\n    ]\n  },\n  //一个对象，每个属性都是node.js全局变量或模块的名称，value为empty表示提供空对象\n  node: {\n    // prevent webpack from injecting useless setImmediate polyfill because Vue\n    // source contains it (although only uses it if it\'s native).\n    setImmediate: false,\n    // prevent webpack from injecting mocks to Node native modules\n    // that does not make sense for the client\n    dgram: \'empty\',\n    fs: \'empty\',\n    net: \'empty\',\n    tls: \'empty\',\n    child_process: \'empty\'\n  }\n}\n```\n\n### 6. webpack.dev.conf.js\n```\n\'use strict\'//js按照严格模式执行\nconst utils = require(\'./utils\')//导入utils.js\nconst webpack = require(\'webpack\')//使用webpack来使用webpack内置插件\nconst config = require(\'../config\')//config文件夹下index.js文件\nconst merge = require(\'webpack-merge\')//引入webpack-merge插件用来合并webpack配置对象，也就是说可以把webpack配置文件拆分成几个小的模块，然后合并\nconst path = require(\'path\')\nconst baseWebpackConfig = require(\'./webpack.base.conf\')//导入webpack基本配置\nconst CopyWebpackPlugin = require(\'copy-webpack-plugin\')\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')//生成html文件\nconst FriendlyErrorsPlugin = require(\'friendly-errors-webpack-plugin\')\nconst portfinder = require(\'portfinder\')//获取port\n\nconst HOST = process.env.HOST//process.env属性返回一个对象，包含了当前shell的所有环境变量。这句取其中的host文件？\nconst PORT = process.env.PORT && Number(process.env.PORT)//获取所有环境变量下的端口？\n//合并模块，第一个参数是webpack基本配置文件webpack.base.conf.js中的配置\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    //创建模块时匹配请求的规则数组,这里调用了utils中的配置模板styleLoaders\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // cheap-module-eval-source-map is faster for development\n  //debtool是开发工具选项，用来指定如何生成sourcemap文件，cheap-module-eval-source-map此款soucemap文件性价比最高\n  devtool: config.dev.devtool,\n\n  // these devServer options should be customized in /config/index.js\n  devServer: {//webpack服务器配置\n    clientLogLevel: \'warning\',//使用内联模式时，在开发工具的控制台将显示消息，可取的值有none error warning info\n    historyApiFallback: {//当使用h5 history api时，任意的404响应都可能需要被替代为index.html，通过historyApiFallback：true控制；通过传入一个对象，比如使用rewrites这个选项进一步控制\n      rewrites: [\n        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, \'index.html\') },\n      ],\n    },\n    hot: true,//是否启用webpack的模块热替换特性。这个功能主要是用于开发过程中，对生产环境无帮助。效果上就是界面无刷新更新。\n    contentBase: false, // since we use CopyWebpackPlugin.这里禁用了该功能。本来是告诉服务器从哪里提供内容，一半是本地静态资源。\n    compress: true,//一切服务是否都启用gzip压缩\n    host: HOST || config.dev.host,//指定一个host,默认是localhost。如果有全局host就用全局，否则就用index.js中的设置。\n    port: PORT || config.dev.port,//指定端口\n    open: config.dev.autoOpenBrowser,//是否在浏览器开启本dev server\n    overlay: config.dev.errorOverlay//当有编译器错误时，是否在浏览器中显示全屏覆盖。\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,//此路径下的打包文件可在浏览器中访问\n    proxy: config.dev.proxyTable,//如果你有单独的后端开发服务器api,并且希望在同域名下发送api请求，那么代理某些URL会很有用。\n    quiet: true, // necessary for FriendlyErrorsPlugin  启用 quiet 后，除了初始启动信息之外的任何内容都不会被打印到控制台。这也意味着来自 webpack 的错误或警告在控制台不可见。\n    watchOptions: {//webpack 使用文件系统(file system)获取文件改动的通知。在某些情况下，不会正常工作。例如，当使用 Network File System (NFS) 时。Vagrant 也有很多问题。在这些情况下使用轮询。\n      poll: config.dev.poll,//是否使用轮询\n    }\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      \'process.env\': require(\'../config/dev.env\')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({//模块HtmlWebpackPlugin\n      filename: \'index.html\',//生成的文件的名称\n      template: \'index.html\',//可以指定模块html文件\n      inject: true//在文档上没查到这个选项 不知道干嘛的。。。\n    }),\n    // copy custom static assets\n    new CopyWebpackPlugin([//模块CopyWebpackPlugin  将单个文件或整个文件复制到构建目录\n      {\n        from: path.resolve(__dirname, \'../static\'),//将static文件夹及其子文件复制到\n        to: config.dev.assetsSubDirectory,\n        ignore: [\'.*\']//这个没翻译好，百度翻译看不懂，请自己查文档。。。\n      }\n    ])\n  ]\n})\n//webpack将运行由配置文件导出的函数，并且等待promise返回，便于需要异步地加载所需的配置变量。\nmodule.exports = new Promise((resolve, reject) => {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  portfinder.getPort((err, port) => {\n    if (err) {\n      reject(err)\n    } else {\n      // publish the new Port, necessary for e2e tests\n      process.env.PORT = port\n      // add port to devServer config\n      devWebpackConfig.devServer.port = port\n\n      // Add FriendlyErrorsPlugin\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({ //出错友好处理插件\n        compilationSuccessInfo: { //build成功的话会执行者块\n          messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors //如果出错就执行这块,其实是utils里面配置好的提示信息\n          ? utils.createNotifierCallback()\n          : undefined\n      }))\n\n      resolve(devWebpackConfig)\n    }\n  })\n})\n```\n\n### 7. webpack.prod.conf.js\n```\'use strict\'\n// 下面是引入nodejs的路径模块\nconst path = require(\'path\')\n// 下面是utils工具配置文件，主要用来处理css类文件的loader\nconst utils = require(\'./utils\')\n// 下面引入webpack，来使用webpack内置插件\nconst webpack = require(\'webpack\')\n// 下面是config目录下的index.js配置文件，主要用来定义了生产和开发环境的相关基础配置\nconst config = require(\'../config\')\n// 下面是webpack的merger插件，主要用来处理配置对象合并的，可以将一个大的配置对象拆分成几个小的，合并，相同的项将覆盖\nconst merge = require(\'webpack-merge\')\n// 下面是webpack.base.conf.js配置文件，我其他博客文章已经解释过了，用来处理不同类型文件的loader\nconst baseWebpackConfig = require(\'./webpack.base.conf\')\n// copy-webpack-plugin使用来复制文件或者文件夹到指定的目录的\nconst CopyWebpackPlugin = require(\'copy-webpack-plugin\')\n// html-webpack-plugin是生成html文件，可以设置模板，之前的文章将过了\nconst HtmlWebpackPlugin = require(\'html-webpack-plugin\')\n// extract-text-webpack-plugin这个插件是用来将bundle中的css等文件产出单独的bundle文件的，之前也详细讲过\nconst ExtractTextPlugin = require(\'extract-text-webpack-plugin\')\n// optimize-css-assets-webpack-plugin插件的作用是压缩css代码的，还能去掉extract-text-webpack-plugin插件抽离文件产生的重复代码，因为同一个css可能在多个模块中出现所以会导致重复代码，换句话说这两个插件是两兄弟\nconst OptimizeCSSPlugin = require(\'optimize-css-assets-webpack-plugin\')\nconst UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\')\n\n// 如果当前环境变量NODE_ENV的值是testing，则导入 test.env.js配置文，设置env为\"testing\"\n// 如果当前环境变量NODE_ENV的值不是testing，则设置env为\"production\"\nconst env = process.env.NODE_ENV === \'testing\'\n  ? require(\'../config/test.env\')\n  : require(\'../config/prod.env\')\n// 把当前的配置对象和基础的配置对象合并\nconst webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    // 下面就是把utils配置好的处理各种css类型的配置拿过来，和dev设置一样，就是这里多了个extract: true，此项是自定义项，设置为true表示，生成独立的文件\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  // devtool开发工具，用来生成个sourcemap方便调试\n  // 按理说这里不用生成sourcemap多次一举，这里生成了source-map类型的map文件，只用于生产环境\n  devtool: false,\n  output: {\n    // 打包后的文件放在dist目录里面\n    path: config.build.assetsRoot,\n    // 文件名称使用 static/js/[name].[chunkhash].js, 其中name就是main,chunkhash就是模块的hash值，用于浏览器缓存的\n    filename: utils.assetsPath(\'js/[name].[chunkhash].js\'),\n    // chunkFilename是非入口模块文件，也就是说filename文件中引用了chunckFilename\n    chunkFilename: utils.assetsPath(\'js/[id].[chunkhash].js\')\n  },\n  plugins: [\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    // 下面是利用DefinePlugin插件，定义process.env环境变量为env\n    new webpack.DefinePlugin({\n      \'process.env\': env\n    }),\n    new UglifyJsPlugin({\n      // UglifyJsPlugin插件是专门用来压缩js文件的\n      uglifyOptions: {\n        compress: {\n          warnings: false // 禁止压缩时候的警告信息，给用户一种vue高大上没有错误的感觉\n        }\n      },\n      // 压缩后生成map文件\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    // extract css into its own file\n    new ExtractTextPlugin({\n      // 生成独立的css文件，下面是生成独立css文件的名称\n      filename: utils.assetsPath(\'css/[name].[contenthash].css\'),\n      // Setting the following option to `false` will not extract CSS from codesplit chunks.\n      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.\n      // It\'s currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it\'s `false`, \n      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110\n      allChunks: true,\n    }),\n    // Compress extracted CSS. We are using this plugin so that possible\n    // duplicated CSS from different components can be deduped.\n    new OptimizeCSSPlugin({\n      // 压缩css文件\n      cssProcessorOptions: false\n    }),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      // 生成html页面\n      filename: process.env.NODE_ENV === \'testing\'\n        ? \'index.html\'\n        : config.build.index,\n      template: \'index.html\',\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      // 分类要插到html页面的模块\n      chunksSortMode: \'dependency\'\n    }),\n    // keep module.id stable when vendor modules does not change\n    new webpack.HashedModuleIdsPlugin(),\n    // enable scope hoisting\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    // split vendor js into its own file\n    // 下面的插件是将打包后的文件中的第三方库文件抽取出来，便于浏览器缓存，提高程序的运行速度\n    new webpack.optimize.CommonsChunkPlugin({\n      // common 模块的名称\n      name: \'vendor\',\n      minChunks(module) {\n        // any required modules inside node_modules are extracted to vendor\n        // 将所有依赖于node_modules下面文件打包到vendor中\n        return (\n          module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(\n            path.join(__dirname, \'../node_modules\')\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    // 把webpack的runtime代码和module manifest代码提取到manifest文件中，防止修改了代码但是没有修改第三方库文件导致第三方库文件也打包的问题\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \'manifest\',\n      minChunks: Infinity\n    }),\n    // This instance extracts shared chunks from code splitted chunks and bundles them\n    // in a separate chunk, similar to the vendor chunk\n    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk\n    new webpack.optimize.CommonsChunkPlugin({\n      name: \'app\',\n      async: \'vendor-async\',\n      children: true,\n      minChunks: 3\n    }),\n\n    // copy custom static assets\n    // 下面是复制文件的插件，我认为在这里并不是起到复制文件的作用，而是过滤掉打包过程中产生的以.开头的文件\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, \'../static\'),\n        to: config.build.assetsSubDirectory,\n        ignore: [\'.*\']\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  // 开启Gzi压缩打包后的文件，老铁们知道这个为什么还能压缩吗？？，就跟你打包压缩包一样，把这个压缩包给浏览器，浏览器自动解压的\n  // 你要知道，vue-cli默认将这个神奇的功能禁用掉的，理由是Surge 和 Netlify 静态主机默认帮你把上传的文件gzip了\n  const CompressionWebpackPlugin = require(\'compression-webpack-plugin\')\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: \'[path].gz[query]\',\n      algorithm: \'gzip\',\n      test: new RegExp( // 这里是把js和css文件压缩\n        \'\\\\.(\' +\n        config.build.productionGzipExtensions.join(\'|\') +\n        \')$\'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  // 打包编译后的文件打印出详细的文件信息，vue-cli默认把这个禁用了，个人觉得还是有点用的，可以自行配置\n  const BundleAnalyzerPlugin = require(\'webpack-bundle-analyzer\').BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n```\n\n### 8.  config文件下的index.js:\n```\'use strict\'\n// Template version: 1.3.1\n// see http://vuejs-templates.github.io/webpack for documentation.\n// path是node.js的路径模块，用来处理路径统一的问题\nconst path = require(\'path\')\n\nmodule.exports = {\n  // 引入当前目录下的dev.env.js，用来指明开发环境\n  dev: {\n\n    // Paths\n    assetsSubDirectory: \'static\',\n    assetsPublicPath: \'/\',\n    proxyTable: {}, // 下面是代理表，作用是用来，建一个虚拟api服务器用来代理本机的请求，只能用于开发模式\n\n    // Various Dev Server settings\n    host: \'localhost\', // can be overwritten by process.env.HOST\n    // 下面是dev-server的端口号，可以自行更改\n    port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined\n    autoOpenBrowser: false, // 下面表示是否自定代开浏览器\n    errorOverlay: true,\n    notifyOnErrors: true,\n    poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions-\n\n    // Use Eslint Loader?\n    // If true, your code will be linted during bundling and\n    // linting errors and warnings will be shown in the console.\n    useEslint: true,\n    // If true, eslint errors and warnings will also be shown in the error overlay\n    // in the browser.\n    showEslintErrorsInOverlay: false,\n\n    /**\n     * Source Maps\n     */\n\n    // https://webpack.js.org/configuration/devtool/#development\n    devtool: \'cheap-module-eval-source-map\',\n\n    // If you have problems debugging vue-files in devtools,\n    // set this to false - it *may* help\n    // https://vue-loader.vuejs.org/en/options.html#cachebusting\n    cacheBusting: true,\n\n    cssSourceMap: true\n  },\n\n  build: {\n    // 下面是build也就是生产编译环境下的一些配置\n    // Template for index.html\n    index: path.resolve(__dirname, \'../dist/index.html\'),\n\n    // Paths\n    assetsRoot: path.resolve(__dirname, \'../dist\'), // 下面定义的是静态资源的根目录 也就是dist目录\n    assetsSubDirectory: \'static\', // 下面定义的是静态资源根目录的子目录static，也就是dist目录下面的static\n    assetsPublicPath: \'./\', // 下面定义的是静态资源的公开路径，也就是真正的引用路径\n\n    /**\n     * Source Maps\n     */\n    // 下面定义是否生成生产环境的sourcmap，sourcmap是用来debug编译后文件的，通过映射到编译前文件来实现\n    productionSourceMap: true,\n    // https://webpack.js.org/configuration/devtool/#production\n    devtool: \'#source-map\',\n\n    // Gzip off by default as many popular static hosts such as\n    // Surge or Netlify already gzip all static assets for you.\n    // Before setting to `true`, make sure to:\n    // npm install --save-dev compression-webpack-plugin\n    productionGzip: false, // 下面是是否在生产环境中压缩代码，如果要压缩必须安装compression-webpack-plugin\n    productionGzipExtensions: [\'js\', \'css\'], // 下面定义要压缩哪些类型的文件\n\n    // Run the build command with an extra argument to\n    // View the bundle analyzer report after build finishes:\n    // `npm run build --report`\n    // Set to `true` or `false` to always turn it on or off\n    // 下面是用来开启编译完成后的报告，可以通过设置值为true和false来开启或关闭 \n    // 下面的process.env.npm_config_report表示定义的一个npm_config_report环境变量，可以自行设置\n    bundleAnalyzerReport: process.env.npm_config_report\n  }\n}\n```\n\n### 9. .eslintrc.js\n```\n// https://eslint.org/docs/user-guide/configuring\n\nmodule.exports = {\n  //此项是用来告诉eslint找当前配置文件不能往父级查找\n  root: true,\n  //此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n  parserOptions: {\n    parser: \'babel-eslint\'\n  },\n  //此项指定环境的全局变量，下面的配置指定为浏览器环境\n  env: {\n    browser: true,\n  },\n  extends: [\n    // https://github.com/vuejs/eslint-plugin-vue#priority-a-essential-error-prevention\n    // consider switching to `plugin:vue/strongly-recommended` or `plugin:vue/recommended` for stricter rules.\n    \'plugin:vue/essential\',\n    // https://github.com/standard/standard/blob/master/docs/RULES-en.md\n    // 此项是用来配置标准的js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n    \'standard\'\n  ],\n  // required to lint *.vue files\n  // 此项是用来提供插件的，插件名称省略了eslint-plugin-，下面这个配置是用来规范html的\n  plugins: [\n    \'vue\'\n  ],\n  // add your custom rules here\n  // 下面这些rules是用来设置从插件来的规范代码的规则，使用必须去掉前缀eslint-plugin-\n  // 主要有如下的设置规则，可以设置字符串也可以设置数字，两者效果一致\n  // \"off\" -> 0 关闭规则\n  // \"warn\" -> 1 开启警告规则\n  //\"error\" -> 2 开启错误规则\n  // 了解了上面这些，下面这些代码相信也看的明白了\n  rules: {\n    // allow async-await\n    \'generator-star-spacing\': \'off\',\n    // allow debugger during development\n    \'no-debugger\': process.env.NODE_ENV === \'production\' ? \'error\' : \'off\',\n  }\n}\n```', '1', '2019-08-15 15:35:56', '2019-08-15 15:36:53');

-- ----------------------------
-- Table structure for `so_tool_items`
-- ----------------------------
DROP TABLE IF EXISTS `so_tool_items`;
CREATE TABLE `so_tool_items` (
  `sid` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(120) NOT NULL,
  `url` varchar(300) NOT NULL,
  `img` varchar(300) NOT NULL,
  `uid` varchar(13) NOT NULL,
  `create_time` datetime NOT NULL,
  `update_time` datetime NOT NULL,
  `type` bigint(20) NOT NULL COMMENT '所属类型',
  PRIMARY KEY (`sid`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of so_tool_items
-- ----------------------------
INSERT INTO `so_tool_items` VALUES ('3', 'php中文网在线工具箱', 'http://www.php.cn/xiazai/tool', 'http://img.php.cn/upload/tool/000/000/001/58df1702d6551986.png', '8AC4E8DG918B1', '2019-08-23 17:33:27', '2019-08-23 17:33:27', '2');
INSERT INTO `so_tool_items` VALUES ('4', 'php中文网在线工具箱', 'http://www.php.cn/xiazai/tool', 'http://img.php.cn/upload/tool/000/000/001/58df1702d6551986.png', '8AC4E8DG918B1', '2019-08-23 17:33:42', '2019-08-23 17:33:42', '2');

-- ----------------------------
-- Table structure for `so_tools`
-- ----------------------------
DROP TABLE IF EXISTS `so_tools`;
CREATE TABLE `so_tools` (
  `sid` bigint(20) NOT NULL AUTO_INCREMENT,
  `title` varchar(60) NOT NULL,
  `uid` varchar(13) NOT NULL,
  `status` tinyint(1) NOT NULL,
  `create_time` datetime DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  PRIMARY KEY (`sid`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of so_tools
-- ----------------------------
INSERT INTO `so_tools` VALUES ('2', '在线工具', '8AC4E8DG918B1', '1', '2019-08-23 10:38:27', '2019-08-23 10:38:27');
INSERT INTO `so_tools` VALUES ('3', '资源下载', '8AC4E8DG918B1', '1', '2019-08-23 10:38:40', '2019-08-23 10:38:40');
INSERT INTO `so_tools` VALUES ('5', '教学相关网站', '8AC4E8DG918B1', '1', '2019-08-23 11:15:30', '2019-08-23 11:15:30');
INSERT INTO `so_tools` VALUES ('6', '娱乐网站', '8AC4E8DG918B1', '1', '2019-08-23 11:19:48', '2019-08-23 14:52:16');
INSERT INTO `so_tools` VALUES ('7', '相关开发手册', '8AC4E8DG918B1', '1', '2019-08-23 11:20:23', '2019-08-23 11:20:23');

-- ----------------------------
-- Table structure for `so_user`
-- ----------------------------
DROP TABLE IF EXISTS `so_user`;
CREATE TABLE `so_user` (
  `sid` bigint(20) NOT NULL AUTO_INCREMENT,
  `uid` varchar(13) NOT NULL COMMENT '用户编号',
  `name` varchar(60) NOT NULL COMMENT '昵称',
  `email` varchar(60) NOT NULL,
  `phone` varchar(20) NOT NULL,
  `password` varchar(40) NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '1' COMMENT '1:启用 0:禁用',
  `sex` tinyint(1) NOT NULL DEFAULT '1' COMMENT '1:男 0:女',
  `create_time` datetime NOT NULL,
  `update_time` datetime NOT NULL,
  PRIMARY KEY (`sid`,`uid`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of so_user
-- ----------------------------
INSERT INTO `so_user` VALUES ('1', '8AC4E8DG918B1', '夏日小呆', '1085556180@qq.com', '18322210395', '948b3c6f1c97e514c2ff5a1e36d0b70ca62ea912', '1', '1', '2019-08-12 11:27:09', '2019-08-12 11:27:09');
